# -*- coding: utf-8 -*-
"""Term_project_reciever.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Njeh57U2TZf0iYmvHX8-W9ZdlGdjZXeN

Reciever Program
"""

# Main be like
import numpy as np
import math
import sys
import fileinput
import os.path
from mpmath import *
mp.dps = 18

"""this is how the output of read_input reading from terminal be like"""
def read_input():
  data = []
  for line in sys.stdin:
       data.append(line)
  return data

def Read_datadatFile():
    with open('data.dat', 'r') as fieldlines:
         line = fieldlines.readlines()
         Pi = float(line[0][0:27]) # to read all significant digits of pi
         c = float(line[1][0:27])
         R = float(line[2][0:27])
         s = float(line[3][0:27])
    return Pi, c, R, s







def deg2radians(a1,a2,a3,Pi):
    return (Pi*(int(a1) + (int(a2)/60) + float(a3)/(60*60)))/180


def PositionInCartesian(a,R,Pi,s):
    split = a.split()
    t = mpf(split[0])
    theta = float(split[4])*deg2radians(split[1],split[2],split[3],Pi)
    phi = float(split[8])*deg2radians(split[5],split[6],split[7],Pi)
    h = float(split[9])
    x = (R + h) * math.cos(theta) * math.cos(phi);
    y = (R + h) * math.cos(theta) * math.sin(phi);
    z = (R + h) * math.sin(theta);
    alpha = (2*Pi*t)/s;
    R3_alpha = np.array([[math.cos(alpha), -math.sin(alpha), 0],[math.sin(alpha), math.cos(alpha), 0],[0, 0, 1]])
    X = np.array([[x],[y],[z]])
    X1 = np.matmul(R3_alpha,X)
    return t,X1

def PositionInCartesian_1(split,R,Pi,s):
    #split = a.split()
    t = mpf(split[0])
    theta = float(split[4])*deg2radians(split[1],split[2],split[3],Pi)
    phi = float(split[8])*deg2radians(split[5],split[6],split[7],Pi)
    h = float(split[9])
    x = (R + h) * math.cos(theta) * math.cos(phi);
    y = (R + h) * math.cos(theta) * math.sin(phi);
    z = (R + h) * math.sin(theta);
    alpha = (2*Pi*t)/s;
    R3_alpha = np.array([[math.cos(alpha), -math.sin(alpha), 0],[math.sin(alpha), math.cos(alpha), 0],[0, 0, 1]])
    X = np.array([[x],[y],[z]])
    X1 = np.matmul(R3_alpha,X)
    return t,X1


def CalculateBounds(Input, aI):
  counter = 1
  while aI + counter < len(Input) and (int(Input[counter + aI].split()[0]) - int(Input[counter - 1 + aI].split()[0])) > 0:
    
    counter = counter + 1
  return counter 


def ReadData(Input,aI):
  bounds = CalculateBounds(Input, aI)
 
  if bounds < 4:
    print("not enough satellites")
  else:
    SatelliteDat = np.zeros([bounds,4])
    start_time = 0
    for j in range(bounds):
      SatelliteDat[j][0] = mpf(Input[aI].split()[1]) # time of satellite signal broadcast
      #print(SatelliteDat[j][0])
      SatelliteDat[j][1] = float(Input[aI].split()[2]) # xs
      SatelliteDat[j][2] = float(Input[aI].split()[3]) # ys
      SatelliteDat[j][3] = float(Input[aI].split()[4]) # zs
      start_time = mpf(start_time + mpf(Input[aI].split()[1]))
      aI = aI + 1 
    start_time = mpf(start_time/(bounds))  
    return SatelliteDat, aI, start_time


def F(X0,c, SatelliteDat1):
  sumF = np.zeros((3,1))
  for i in range(SatelliteDat1.shape[0]-1):
    Ai = np.linalg.norm(SatelliteDat1[i+1][1:4].reshape((3,1)) - X0) - np.linalg.norm(SatelliteDat1[i][1:4].reshape((3,1)) - X0) - c*(SatelliteDat1[i][0].reshape((1,1)) - SatelliteDat1[i+1][0].reshape((1,1)) )
    Xi = (SatelliteDat1[i][1:4].reshape((3,1)) - X0)/(np.linalg.norm(SatelliteDat1[i][1:4].reshape((3,1)) - X0)) - ((SatelliteDat1[i+1][1:4].reshape((3,1)) - X0)/(np.linalg.norm(SatelliteDat1[i+1][1:4].reshape((3,1)) - X0)))
    sumF = sumF + 2*Ai*Xi
  return sumF


"""Checking to see if the reciver was above horizon

"""

def computeXs(v,t,R,Pi,S_i):
  x = (R + S_i[v][7])*(S_i[v][0]*math.cos((2*Pi*t)/(S_i[v][6]) + S_i[v][8]) + S_i[v][3]*math.sin((2*Pi*t)/(S_i[v][6]) + S_i[v][8]))
  y = (R + S_i[v][7])*(S_i[v][1]*math.cos((2*Pi*t)/(S_i[v][6]) + S_i[v][8]) + S_i[v][4]*math.sin((2*Pi*t)/(S_i[v][6]) + S_i[v][8]))
  z = (R + S_i[v][7])*(S_i[v][2]*math.cos((2*Pi*t)/(S_i[v][6]) + S_i[v][8]) + S_i[v][5]*math.sin((2*Pi*t)/(S_i[v][6]) + S_i[v][8]))
  return np.array([[x],[y],[z]])

def HorizonCheckReciever(tv,Xv,S_xyz):
   retVal = np.zeros(S_xyz.shape[0],dtype = int)
   for i in range(S_xyz.shape[0]):
      U = np.matmul(Xv.T,S_xyz[i][1:4])
      L = np.matmul(Xv.T,Xv)
      U = np.squeeze(np.asarray(U))
     
      L = np.squeeze(np.asarray(L))
      
      retVal[i] = (U > L)
      
 
   return retVal


def Jacobian(X0, c, SatelliteDat1):
  J1 = 0
  J2 = 0
  J3 = 0
  J4 = 0
  J5 = 0
  J6 = 0
  for i in range(SatelliteDat1.shape[0]-1):
    Ai = np.linalg.norm(SatelliteDat1[i+1][1:4].reshape((3,1)) - X0) - np.linalg.norm(SatelliteDat1[i][1:4].reshape((3,1)) - X0) - c*(SatelliteDat1[i][0].reshape((1,1)) - SatelliteDat1[i+1][0].reshape((1,1)) )
    xi = (SatelliteDat1[i][1].reshape((1,1)) - X0[0])/(np.linalg.norm(SatelliteDat1[i][1:4].reshape((3,1)) - X0)) - ((SatelliteDat1[i+1][1].reshape((1,1)) - X0[0])/(np.linalg.norm(SatelliteDat1[i+1][1:4].reshape((3,1)) - X0)))
    dxi_dx_1part = (math.pow(np.linalg.norm(SatelliteDat1[i+1][1:4].reshape((3,1)) - X0),2) - math.pow((SatelliteDat1[i+1][1].reshape((1,1))) - X0[0],2))/(math.pow(np.linalg.norm(SatelliteDat1[i+1][1:4].reshape((3,1)) - X0),3))
    dxi_dx_2part = (math.pow(np.linalg.norm(SatelliteDat1[i][1:4].reshape((3,1)) - X0),2) - math.pow((SatelliteDat1[i][1].reshape((1,1))) - X0[0],2))/(math.pow(np.linalg.norm(SatelliteDat1[i][1:4].reshape((3,1)) - X0),3))
    dxi_dx = dxi_dx_1part + dxi_dx_2part
  
    J1 = J1 + 2*(math.pow(xi,2) + Ai*dxi_dx)
    #print(J1)

    yi = (SatelliteDat1[i][2].reshape((1,1)) - X0[1])/(np.linalg.norm(SatelliteDat1[i][1:4].reshape((3,1)) - X0)) - ((SatelliteDat1[i+1][2].reshape((1,1)) - X0[1])/(np.linalg.norm(SatelliteDat1[i+1][1:4].reshape((3,1)) - X0)))
    
    dxi_dy_1part = (((SatelliteDat1[i+1][2].reshape((1,1))) - X0[1])*((SatelliteDat1[i+1][1].reshape((1,1))) - X0[0]))/(math.pow(np.linalg.norm(SatelliteDat1[i+1][1:4].reshape((3,1)) - X0),3))
    dxi_dy_2part = (((SatelliteDat1[i][2].reshape((1,1))) - X0[1])*((SatelliteDat1[i][1].reshape((1,1))) - X0[0]))/(math.pow(np.linalg.norm(SatelliteDat1[i][1:4].reshape((3,1)) - X0),3))
    dxi_dy = -dxi_dy_1part + dxi_dy_2part

    J2 = J2 + 2*(xi*yi + Ai*dxi_dy)
    #print(J2)

    zi = (SatelliteDat1[i][3].reshape((1,1)) - X0[2])/(np.linalg.norm(SatelliteDat1[i][1:4].reshape((3,1)) - X0)) - ((SatelliteDat1[i+1][3].reshape((1,1)) - X0[2])/(np.linalg.norm(SatelliteDat1[i+1][1:4].reshape((3,1)) - X0)))
    
    dxi_dz_1part = (((SatelliteDat1[i+1][1].reshape((1,1))) - X0[0])*((SatelliteDat1[i+1][3].reshape((1,1))) - X0[2]))/(math.pow(np.linalg.norm(SatelliteDat1[i+1][1:4].reshape((3,1)) - X0),3))
    dxi_dz_2part = (((SatelliteDat1[i][1].reshape((1,1))) - X0[0])*((SatelliteDat1[i][3].reshape((1,1))) - X0[2]))/(math.pow(np.linalg.norm(SatelliteDat1[i][1:4].reshape((3,1)) - X0),3))
    dxi_dz = -dxi_dz_1part + dxi_dz_2part

    J3 = J3 + 2*(xi*zi + Ai*dxi_dz)
    #print(J3)
    

    dyi_dy_1part = (math.pow(np.linalg.norm(SatelliteDat1[i+1][1:4].reshape((3,1)) - X0),2) - math.pow((SatelliteDat1[i+1][2].reshape((1,1))) - X0[1],2))/(math.pow(np.linalg.norm(SatelliteDat1[i+1][1:4].reshape((3,1)) - X0),3))
    dyi_dy_2part = (math.pow(np.linalg.norm(SatelliteDat1[i][1:4].reshape((3,1)) - X0),2) - math.pow((SatelliteDat1[i][2].reshape((1,1))) - X0[1],2))/(math.pow(np.linalg.norm(SatelliteDat1[i][1:4].reshape((3,1)) - X0),3))
    dyi_dy = dyi_dy_1part + dyi_dy_2part

    J4 = J4 + 2*(math.pow(yi,2) + Ai*dyi_dy)
    #print(J4)
    dyi_dz_1part = (((SatelliteDat1[i+1][2].reshape((1,1))) - X0[1])*((SatelliteDat1[i+1][3].reshape((1,1))) - X0[2]))/(math.pow(np.linalg.norm(SatelliteDat1[i+1][1:4].reshape((3,1)) - X0),3))
    dyi_dz_2part = (((SatelliteDat1[i][2].reshape((1,1))) - X0[1])*((SatelliteDat1[i][3].reshape((1,1))) - X0[2]))/(math.pow(np.linalg.norm(SatelliteDat1[i][1:4].reshape((3,1)) - X0),3))
    dyi_dz = -dyi_dz_1part + dyi_dz_2part

    J5 = J5 + 2*(yi*zi + Ai*dyi_dz)
    #print(J5)
    
    dzi_dz_1part = (math.pow(np.linalg.norm(SatelliteDat1[i+1][1:4].reshape((3,1)) - X0),2) - math.pow((SatelliteDat1[i+1][3].reshape((1,1))) - X0[2],2))/(math.pow(np.linalg.norm(SatelliteDat1[i+1][1:4].reshape((3,1)) - X0),3))
    dzi_dz_2part = (math.pow(np.linalg.norm(SatelliteDat1[i][1:4].reshape((3,1)) - X0),2) - math.pow((SatelliteDat1[i][3].reshape((1,1))) - X0[2],2))/(math.pow(np.linalg.norm(SatelliteDat1[i][1:4].reshape((3,1)) - X0),3))
    dzi_dz = dzi_dz_1part + dzi_dz_2part
    J6 = J6 + 2*(math.pow(zi,2) + Ai*dzi_dz)
    #print(J6)
    Jac = np.array([[J1, J2, J3],[J2, J4, J5],[J3, J5, J6]])
    Jac1 = Jac.reshape((3,3))
  return Jac1



def NewtonsMethod(X0,step,R,Pi,c,SatelliteDat1):
  Sk = np.linalg.solve(Jacobian(X0,c,SatelliteDat1),F(X0,c,SatelliteDat1))
  retVal = X0
  retVal = retVal - Sk
  if abs(retVal[0] - X0[0])<0.0000001 and abs(retVal[1] - X0[1])<0.0000001 and abs(retVal[2] - X0[2])<0.0000001:
    return retVal
  elif (step>100):
    print('No convergence')
    sys.exit()
    return None
  else:
    step = step + 1
    return NewtonsMethod(retVal,step, R, Pi, c, SatelliteDat1)



def TimeAT(Xv,SatelliteDat1,c):
  Tv = SatelliteDat1[0][0] + (1/c) * (math.sqrt(math.pow(Xv[0]-SatelliteDat1[0][1], 2)+math.pow(Xv[1]-SatelliteDat1[0][2], 2)+math.pow(Xv[2]-SatelliteDat1[0][3], 2)))
  if Tv < 0.01/c:
    Tv = 0.0
  return Tv


def RadiansToDegrees(a,Pi):
  Radians = a
  if Radians < -Pi or Radians > Pi:
    n = int((Radians + Pi)/(2*Pi))
    if Radians < 0:
      n = n-1
    Radians = Radians -n*2*Pi
  theta = Radians
  if theta >= 0:
    plus = 1
  else:
    plus = -1
    theta = -theta

  degs = theta*360/(2*Pi)
  degrees = int(degs)
  degs = degs - degrees
  degs = 60*degs
  minutes = int(degs)
  degs = degs - minutes
  seconds = 60*degs
  if abs(60-seconds) < 1.0E-3:
    seconds = 0
    minutes = minutes + 1
  if minutes == 60:
    minutes = 0
    minutes = minutes + 1
  if degrees < 0 or degrees > 180 or minutes < 0 or minutes > 59 or seconds < 0.0 or seconds >=60.0 or Radians < -Pi or Radians > Pi:
    print('angles error')
  
  return degrees, minutes, seconds, plus





def PositionInGeographic(XV,TV,R, Pi, c, s):
  t = TV

  alpha = -(2*Pi*t)/s
  R3_negalpha = np.array([[math.cos(alpha), -math.sin(alpha), 0],[math.sin(alpha), math.cos(alpha), 0],[0, 0, 1]])
  X1 = np.matmul(R3_negalpha,XV)
  #print(X1[0])
  if X1[0] == 0 and X1[1] == 0:
    if X1[2] >= 0:
      psi = Pi/2
    else:
      psi = -1*(Pi/2)
  else:
    psi = math.atan(X1[2]/(math.sqrt(math.pow(X1[0],2)+ math.pow(X1[1],2))))
  if X1[0] > 0 and X1[1] > 0:
    lambdA = math.atan(X1[1]/X1[0])
  elif X1[0] < 0:
    lambdA = Pi + math.atan((X1[1])/(X1[0]))
  elif X1[0] > 0 and X1[1] < 0:
    lambdA = 2*Pi + math.atan((X1[1])/(X1[0]))
  lambdA = lambdA - 2*Pi
  
  Psi = RadiansToDegrees(psi,Pi)
  Lambda = RadiansToDegrees(lambdA,Pi)
  h = math.sqrt(X1[0]*X1[0] + X1[1]*X1[1] + X1[2]*X1[2]) - R
  

  return h, Psi, Lambda


def ComputeLocation(X0, t0, SatelliteDat1,R, Pi, c, s):
  #print(X0)
  XV = NewtonsMethod(X0,0,R,Pi,c,SatelliteDat1)
  #print(XV)
  TV = TimeAT(XV, SatelliteDat1, c)
  h, Psi, Lambda = PositionInGeographic(XV,TV,R, Pi, c, s)#output of positon and time in geographic 
  return TV, Psi, Lambda, h




# Main

aI = 0
b12 = '0.0 40 45 55.0 1 111 50 58.0 -1 1372.0'# starting point
#b12 = '0 90 0 0 1 150 0 0 1 0'
b12_dash = b12.split()[1:]
Path = os.path.exists('receiver.log')
if Path == True:
  open('receiver.log','w').close()
  Input = read_input()


  [Pi,c,R,s] = Read_datadatFile()
  while aI < len(Input):
    data, aI, start_time = ReadData(Input, aI)
    with open('receiver.log','ab') as f:
      f.write(b'\n')
      np.savetxt(f,data)
      f.write(b'\n')
    a1 = [str(data[0][0])] + b12_dash
    tv1,Xv1= PositionInCartesian_1(a1,R,Pi,s)
    with open('receiver.log','a') as f2:
      f2.write('starting time and position of vehicle' + "\n")
      f2.write(str(tv1))
    with open('receiver.log','ab') as f:
      f.write(b'\n')
      np.savetxt(f,Xv1)
    B = HorizonCheckReciever(tv1, Xv1, data)
    if sum(B) > 3:
      data1 = data[np.where(B)]
      TV, Psi, Lambda, h = ComputeLocation(Xv1, tv1, data1, R, Pi, c, s)
      output_to_term = str((TV)) + " "  + str(Psi[0]) + " "  + str(Psi[1]) + " " + str(Psi[2])+ " " + str(Psi[3]) + " " + str(Lambda[0]) + " "  + str(Lambda[1]) + " " + str(Lambda[2])+ " " + str(Lambda[3]) + " " + str(h)
      print(output_to_term)
      with open('receiver.log','a') as f1:
        f1.write("receiver output" + "\n")
        f1.write(output_to_term + "\n")
else:

  Input = read_input()


  [Pi,c,R,s] = Read_datadatFile()
  while aI < len(Input):
    data, aI, start_time = ReadData(Input, aI)
    with open('receiver.log','ab') as f:
      f.write(b'\n')
      np.savetxt(f,data)
      f.write(b'\n')
    a1 = [str(data[0][0])] + b12_dash
    tv1,Xv1= PositionInCartesian_1(a1,R,Pi,s)
    with open('receiver.log','a') as f2:
      f2.write('starting time and position of vehicle' + "\n")
      f2.write(str(tv1))
    with open('receiver.log','ab') as f:
      f.write(b'\n')
      np.savetxt(f,Xv1)
    B = HorizonCheckReciever(tv1, Xv1, data)
    if sum(B) > 3:
      data1 = data[np.where(B)]
      TV, Psi, Lambda, h = ComputeLocation(Xv1, tv1, data1, R, Pi, c, s)
      output_to_term = str((TV)) + " "  + str(Psi[0]) + " "  + str(Psi[1]) + " " + str(Psi[2])+ " " + str(Psi[3]) + " " + str(Lambda[0]) + " "  + str(Lambda[1]) + " " + str(Lambda[2])+ " " + str(Lambda[3]) + " " + str(h)
      print(output_to_term)
      with open('receiver.log','a') as f1:
        f1.write("receiver output" + "\n")
        f1.write(output_to_term + "\n")

