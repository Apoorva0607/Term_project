# -*- coding: utf-8 -*-
"""Term_project

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1k1L2x64yiNyXXwE67YcC6PMhKOTPHySd

Add all the required function to create satellite.py - Input - data from vehicle.java ( given by professor)
Output - satellite.log file

1) The satellite function will read the data.dat file by input_dat function 

2) Convert latitude and longitude to cartesian coordinates for both vehicle and satellite

3) Check which satellites are above horizon

4) compute Ts and Xs - write this to satellite.log - (We use newton's method, satellite trajectory information to do this ) 

After we have made sure all the functions work well, the order in which the satellite.py will excute as

2D numpy arry S_i - 24 by 9 array

1D numpy array Xv, Xs
	
String path;

List output;

2) intialize()

3) read_input_give_output()

"""

import numpy as np
import math
import sys
import fileinput
from os.path import exists
from mpmath import *
mp.dps = 18

 # Input function or initialize fucntion
def input_dat():
    file = open("satellite.log", "a")
    with open('data.dat', 'r') as fieldlines:
         line = fieldlines.readlines()
         for listitems in line:
             file.write(listitems)
         Pi = float(line[0][0:27]) # to read all significant digits of pi
         c = float(line[1][0:27])
         R = float(line[2][0:27])
         s = float(line[3][0:27])
     
         S = []
         counter = 4
         for i in range(4,220):
             s1 = float(line[i][0:27])
             S.append(s1)

         S_i = np.reshape(S, (24, 9))   # There 24 satellites and each satellite has 9 entries 
    file.close()
    return S_i, Pi, c, R, s

def deg2radians(a1,a2,a3,Pi):
    return (Pi*(int(a1) + (int(a2)/60) + float(a3)/(60*60)))/180



def PositionInCartesian(a,R,Pi,s):
    split = a.split()
    t = mpf(split[0])
    theta = float(split[4])*deg2radians(split[1],split[2],split[3],Pi)
    phi = float(split[8])*deg2radians(split[5],split[6],split[7],Pi)
    h = float(split[9])
    x = (R + h) * math.cos(theta) * math.cos(phi);
    y = (R + h) * math.cos(theta) * math.sin(phi);
    z = (R + h) * math.sin(theta);
    alpha = (2*Pi*t)/s;
    R3_alpha = np.array([[math.cos(alpha), -math.sin(alpha), 0],[math.sin(alpha), math.cos(alpha), 0],[0, 0, 1]])
    X = np.array([[x],[y],[z]])
    X1 = np.dot(R3_alpha,X)
    return t,X1


def computeXs(v,t,R,Pi,S_i):
  x = (R + S_i[v][7])*(S_i[v][0]*math.cos((2*Pi*t)/(S_i[v][6]) + S_i[v][8]) + S_i[v][3]*math.sin((2*Pi*t)/(S_i[v][6]) + S_i[v][8]))
  y = (R + S_i[v][7])*(S_i[v][1]*math.cos((2*Pi*t)/(S_i[v][6]) + S_i[v][8]) + S_i[v][4]*math.sin((2*Pi*t)/(S_i[v][6]) + S_i[v][8]))
  z = (R + S_i[v][7])*(S_i[v][2]*math.cos((2*Pi*t)/(S_i[v][6]) + S_i[v][8]) + S_i[v][5]*math.sin((2*Pi*t)/(S_i[v][6]) + S_i[v][8]))
  return np.array([[x],[y],[z]])



def HorizonCheck(tv,Xv,S_i):
   retVal = np.zeros(24)
   for i in range(24):
      S_xyz = computeXs(i, tv, R, Pi, S_i)
      U = np.matmul(Xv.T,S_xyz)
      L = np.matmul(Xv.T,Xv)
      U = np.squeeze(np.asarray(U))
      L = np.squeeze(np.asarray(L))

  
      
      retVal[i] = (U > L)
      
 
   return retVal



"""Function to convert geopgrahic coordinates to cartesia and vice versa - Follow the HW1 solutions """

def computeTs(v, S_i, Xv, tv, c):
  t0 = tv
  
  norm = np.linalg.norm((computeXs(v,tv,R,Pi,S_i) - Xv))
  t0 = t0 - norm/c
  step = 0
  return NewtonsMethod(v,t0, step,Xv, tv)

def NewtonsMethod(v,Tk,step, Xv,tv):
  returVal = Tk
  returVal = Tk - (F(v,Tk,tv,S_i,Xv)/DF(v,Tk,tv,S_i,Xv))
  if returVal - Tk <= 0.01/c:
    return returVal
  elif (step > 9):
    return -1
  else:
    return NewtonsMethod(v, returVal, step+1, Xv, tv)

def F(v,t,tv,S_i,Xv):
    F_out = np.dot((computeXs(v,t,R,Pi,S_i) - Xv).T, (computeXs(v,t,R,Pi,S_i) - Xv)) -1*c*c*(tv-t)*(tv-t)

    return F_out

def DF(v,t,tv,S_i,Xv):
    DF_out = 2*(np.dot((computeXs(v,t,R,Pi,S_i) - Xv).T,computeXs_dash(v,t,R,Pi,S_i))) + 2*c*c*(tv - t)

    return DF_out

def computeXs_dash(v,t,R,Pi,S_i):
  x = 2*Pi*(1/(S_i[v][6]))*(R + S_i[v][7])*(S_i[v][3]*math.cos((2*Pi*t)/S_i[v][6] + S_i[v][8]) - S_i[v][0]*math.sin((2*Pi*t)/S_i[v][6] + S_i[v][8]))
  y = 2*Pi*(1/(S_i[v][6]))*(R + S_i[v][7])*(S_i[v][4]*math.cos((2*Pi*t)/S_i[v][6] + S_i[v][8]) - S_i[v][1]*math.sin((2*Pi*t)/S_i[v][6] + S_i[v][8]))
  z = 2*Pi*(1/(S_i[v][6]))*(R + S_i[v][7])*(S_i[v][5]*math.cos((2*Pi*t)/S_i[v][6] + S_i[v][8]) - S_i[v][2]*math.sin((2*Pi*t)/S_i[v][6] + S_i[v][8]))
  return np.array([[x],[y],[z]])

"""Check if the satellite is above horizon - fucntion

Xv^T(Xs-Xv)> 0

This requires first writng a function for the trajectory of Xs
"""

def ProcessLine(Str, R , Pi, s, c, S_i):
  tv,Xv = PositionInCartesian(Str,R,Pi,s)
  output = []
  B = HorizonCheck(tv, Xv, S_i)
  for k in range(B.shape[0]):
    if B[k] > 0:
      Ts = computeTs(k, S_i, Xv, tv, c)[0]
      Xs = computeXs(k, Ts, R, Pi, S_i)

      output_to_term = str(k) + " " + str((Ts[0])).lstrip('[').rstrip(']') + " "  + str(Xs[0]).lstrip('[').rstrip(']') + " " + str(Xs[1]).lstrip('[').rstrip(']') + " " + str(Xs[2]).lstrip('[').rstrip(']')
      print(output_to_term)
      output.append(output_to_term)
      
     
  return output



# Main would be like

def read_input_give_output(S_i, Pi, c, R, s):
    file = open("satellite.log", "a")
    for line in sys.stdin:
        data = line
        file.write("\n" + data + "\n")
        output = ProcessLine(line, R , Pi, s, c, S_i)  # this fuction will take each line from vehicle class output, convert into cartesian, check for sat aboe horizon, compute Ts, Xs for each of the sat above horizon
        for Lin in output:
            file.write(Lin + "\n")
    file.close()    
    return None

# Main

Path = exists('satellite.log')
if Path == True:
    open('satellite.log','w').close()
    [S_i, Pi, c, R, s] = input_dat() 
    read_input_give_output(S_i, Pi, c, R, s)
else:
    [S_i, Pi, c, R, s] = input_dat() 
    read_input_give_output(S_i, Pi, c, R, s)















